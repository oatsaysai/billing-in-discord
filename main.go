package main

import (
	"bytes"
	"context"
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	pp "github.com/Frontware/promptpay"
	"github.com/bwmarrin/discordgo"
	"github.com/spf13/viper"
	"github.com/yeqown/go-qrcode/v2"
	"github.com/yeqown/go-qrcode/writer/standard"
)

var (
	dg *discordgo.Session
)

type BillItem struct {
	Description string
	Amount      float64
	SharedWith  []string
}

type MultiItemBill struct {
	InitiatorID string
	ChannelID   string
	PromptPayID string
	Items       []BillItem
	IsActive    bool
	Timestamp   time.Time
	MessageID   string
}

var (
	activeBills      = make(map[string]*MultiItemBill)
	activeBillsMutex = &sync.RWMutex{}
	userMentionRegex = regexp.MustCompile(`<@!?(\d+)>`)
	txIDRegex        = regexp.MustCompile(`\(TxID:\s?(\d+)\)`)
)

func messageHandler(s *discordgo.Session, m *discordgo.MessageCreate) {
	if m.Author.ID == s.State.User.ID {
		return
	}

	if m.MessageReference != nil && m.MessageReference.MessageID != "" {
		activeBillsMutex.RLock()
		bill, isActiveInChannel := activeBills[m.ChannelID]
		activeBillsMutex.RUnlock()

		if isActiveInChannel && bill.IsActive && bill.InitiatorID == m.Author.ID && bill.MessageID == m.MessageReference.MessageID {
			if strings.ToLower(strings.TrimSpace(m.Content)) == "!bill finish" {
				go handleBillFinish(s, m, bill)
				return
			}
			if parsedItem, err := parseBillItem(m.Content); err == nil {
				activeBillsMutex.Lock()
				bill.Items = append(bill.Items, parsedItem)
				activeBillsMutex.Unlock()
				s.MessageReactionAdd(m.ChannelID, m.ID, "üëç")
				return
			}
		} else if len(m.Attachments) > 0 {
			go handleSlipVerification(s, m)
			return
		}
	}

	content := strings.TrimSpace(m.Content)
	args := strings.Fields(content)
	if len(args) == 0 {
		return
	}
	command := strings.ToLower(args[0])

	switch {
	case command == "!bill":
		if len(args) > 1 && strings.ToLower(args[1]) == "start" {
			go handleBillStart(s, m)
		} else if len(args) > 1 && strings.ToLower(args[1]) == "finish" {
			activeBillsMutex.RLock()
			bill, isActiveInChannel := activeBills[m.ChannelID]
			activeBillsMutex.RUnlock()
			if isActiveInChannel && bill.IsActive && bill.InitiatorID == m.Author.ID {
				go handleBillFinish(s, m, bill)
			} else {
				sendErrorMessage(s, m.ChannelID, "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏¥‡∏•‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏¢‡∏π‡πà ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏¥‡∏•‡∏ô‡∏µ‡πâ")
			}
		} else {
			go handleSingleLineBill(s, m)
		}
	case command == "!qr":
		go handleQrCommand(s, m)
	case command == "!mydebts":
		go handleMyDebts(s, m)
	case command == "!owedtome", command == "!mydues":
		go handleOwedToMe(s, m)
	case command == "!debts" && len(args) > 1 && userMentionRegex.MatchString(args[1]):
		go handleDebtsOfUser(s, m, args[1:])
	case command == "!dues" && len(args) > 1 && userMentionRegex.MatchString(args[1]):
		go handleDuesForUser(s, m, args[1:])
	case command == "!paid":
		go updatePaidStatus(s, m)
	case command == "!request":
		go handleRequestPayment(s, m)
	case command == "!help":
		go handleHelpCommand(s, m, args)
	}
}

func parseSingleLineBillArgs(content string) (amount float64, description string, mentions []string, promptPayID string, err error) {
	normalizedContent := strings.ToLower(content)
	trimmedContent := strings.TrimSpace(strings.TrimPrefix(normalizedContent, "!bill "))
	parts := strings.Fields(trimmedContent)
	if len(parts) < 4 {
		return 0, "", nil, "", fmt.Errorf("‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö `!bill` ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ: `!bill <‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô> for <‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î> with @user1 @user2... [YourPromptPayID]`")
	}
	parsedAmount, amountErr := strconv.ParseFloat(parts[0], 64)
	if amountErr != nil {
		return 0, "", nil, "", fmt.Errorf("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô '%s' ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç", parts[0])
	}
	amount = parsedAmount
	forIndex, withIndex := -1, -1
	for i, p := range parts {
		if p == "for" && forIndex == -1 {
			forIndex = i
		}
		if p == "with" && withIndex == -1 {
			withIndex = i
		}
	}
	if forIndex != 1 || withIndex == -1 || forIndex >= withIndex {
		return 0, "", nil, "", fmt.Errorf("‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ 'for' ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô ‡πÅ‡∏•‡∏∞ 'with' ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î")
	}
	description = strings.Join(parts[forIndex+1:withIndex], " ")
	if description == "" {
		return 0, "", nil, "", fmt.Errorf("‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏´‡πâ‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏á")
	}
	mentionAndPPIDParts := parts[withIndex+1:]
	if len(mentionAndPPIDParts) == 0 {
		return 0, "", nil, "", fmt.Errorf("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏´‡∏•‡∏±‡∏á 'with'")
	}
	var foundMentions []string
	var potentialPPID string
	for i, part := range mentionAndPPIDParts {
		if userMentionRegex.MatchString(part) {
			match := userMentionRegex.FindStringSubmatch(part)
			if len(match) > 1 {
				foundMentions = append(foundMentions, match[1])
			}
		} else if i == len(mentionAndPPIDParts)-1 {
			if regexp.MustCompile(`^(\d{10}|\d{13}|ewallet-\d+)$`).MatchString(part) {
				potentialPPID = part
			} else {
				return 0, "", nil, "", fmt.Errorf("‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏´‡∏£‡∏∑‡∏≠ PromptPayID ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏™‡πà‡∏ß‡∏ô‡∏ó‡πâ‡∏≤‡∏¢: '%s'", part)
			}
		} else {
			return 0, "", nil, "", fmt.Errorf("‡∏û‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á '%s' ‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ", part)
		}
	}
	if len(foundMentions) == 0 {
		return 0, "", nil, "", fmt.Errorf("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢ @")
	}
	return amount, description, foundMentions, potentialPPID, nil
}

func parseQrArgs(content string) (amount float64, toUser string, description string, promptPayID string, err error) {
	normalizedContent := strings.ToLower(content)
	trimmedContent := strings.TrimSpace(strings.TrimPrefix(normalizedContent, "!qr "))
	parts := strings.Fields(trimmedContent)
	if len(parts) < 6 {
		return 0, "", "", "", fmt.Errorf("‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö `!qr` ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ: `!qr <‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô> to @user for <‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î> <YourPromptPayID>`")
	}
	parsedAmount, amountErr := strconv.ParseFloat(parts[0], 64)
	if amountErr != nil {
		return 0, "", "", "", fmt.Errorf("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô '%s' ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á", parts[0])
	}
	amount = parsedAmount
	if parts[1] != "to" {
		return 0, "", "", "", fmt.Errorf("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ 'to'")
	}
	if !userMentionRegex.MatchString(parts[2]) {
		return 0, "", "", "", fmt.Errorf("‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏ @user ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏•‡∏±‡∏á 'to'")
	}
	toUser = userMentionRegex.FindStringSubmatch(parts[2])[1]
	if parts[3] != "for" {
		return 0, "", "", "", fmt.Errorf("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏≥‡∏ß‡πà‡∏≤ 'for'")
	}
	promptPayID = parts[len(parts)-1]
	if !regexp.MustCompile(`^(\d{10}|\d{13}|ewallet-\d+)$`).MatchString(promptPayID) {
		return 0, "", "", "", fmt.Errorf("PromptPayID '%s' ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏™‡πà‡∏ß‡∏ô‡∏ó‡πâ‡∏≤‡∏¢", promptPayID)
	}
	if len(parts)-1 <= 4 {
		return 0, "", "", "", fmt.Errorf("‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏´‡πâ‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏á")
	}
	description = strings.Join(parts[4:len(parts)-1], " ")
	if description == "" {
		return 0, "", "", "", fmt.Errorf("‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏´‡πâ‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏á")
	}
	return amount, toUser, description, promptPayID, nil
}

func parseRequestPaymentArgs(content string) (debtorDiscordID string, creditorPromptPayID string, err error) {
	parts := strings.Fields(content)
	if len(parts) != 3 {
		return "", "", fmt.Errorf("‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ: `!request @‡∏•‡∏π‡∏Å‡∏´‡∏ô‡∏µ‡πâ <PromptPayID‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì>`")
	}
	if !userMentionRegex.MatchString(parts[1]) {
		return "", "", fmt.Errorf("‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏ @‡∏•‡∏π‡∏Å‡∏´‡∏ô‡∏µ‡πâ ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")
	}
	debtorDiscordID = userMentionRegex.FindStringSubmatch(parts[1])[1]
	creditorPromptPayID = parts[2]
	if !regexp.MustCompile(`^(\d{10}|\d{13}|ewallet-\d+)$`).MatchString(creditorPromptPayID) {
		return "", "", fmt.Errorf("PromptPayID '%s' ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á", creditorPromptPayID)
	}
	return debtorDiscordID, creditorPromptPayID, nil
}

func parseBillItem(content string) (BillItem, error) {
	var item BillItem
	normalizedContent := strings.ToLower(content)
	parts := strings.Fields(normalizedContent)
	if len(parts) < 4 {
		return item, fmt.Errorf("‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ: `<‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô> for <‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î> with @user1 @user2...`")
	}
	amountNum, err := strconv.ParseFloat(parts[0], 64)
	if err != nil {
		return item, fmt.Errorf("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: '%s'", parts[0])
	}
	item.Amount = amountNum
	forIndex, withIndex := -1, -1
	for i, p := range parts {
		if p == "for" && forIndex == -1 {
			forIndex = i
		}
		if p == "with" && withIndex == -1 {
			withIndex = i
		}
	}
	if forIndex != 1 || withIndex == -1 || forIndex >= withIndex {
		return item, fmt.Errorf("‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: ‡πÇ‡∏õ‡∏£‡∏î‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ 'for' ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô ‡πÅ‡∏•‡∏∞ 'with' ‡∏≠‡∏¢‡∏π‡πà‡∏´‡∏•‡∏±‡∏á‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î")
	}
	item.Description = strings.Join(parts[forIndex+1:withIndex], " ")
	if item.Description == "" {
		return item, fmt.Errorf("‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡πâ‡∏≤‡∏°‡∏ß‡πà‡∏≤‡∏á")
	}
	mentionParts := parts[withIndex+1:]
	if len(mentionParts) == 0 {
		return item, fmt.Errorf("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ '%s'", item.Description)
	}
	for _, p := range mentionParts {
		if userMentionRegex.MatchString(p) {
			item.SharedWith = append(item.SharedWith, userMentionRegex.FindStringSubmatch(p)[1])
		} else {
			return item, fmt.Errorf("‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á '%s' ‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ '%s'", p, item.Description)
		}
	}
	if len(item.SharedWith) == 0 {
		return item, fmt.Errorf("‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ '%s'", item.Description)
	}
	return item, nil
}

func sendErrorMessage(s *discordgo.Session, channelID string, message string) {
	log.Printf("ERROR to user (Channel: %s): %s", channelID, message)
	_, err := s.ChannelMessageSend(channelID, fmt.Sprintf("‚ö†Ô∏è ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: %s", message))
	if err != nil {
		log.Printf("Failed to send error message to Discord: %v", err)
	}
}

func getOrCreateDBUser(discordID string) (int, error) {
	var dbUserID int
	err := dbPool.QueryRow(context.Background(), `SELECT id FROM users WHERE discord_id = $1`, discordID).Scan(&dbUserID)
	if err == nil {
		return dbUserID, nil
	}
	err = dbPool.QueryRow(context.Background(), `INSERT INTO users (discord_id) VALUES ($1) RETURNING id`, discordID).Scan(&dbUserID)
	if err != nil {
		log.Printf("Failed to insert user %s: %v", discordID, err)
		fetchErr := dbPool.QueryRow(context.Background(), `SELECT id FROM users WHERE discord_id = $1`, discordID).Scan(&dbUserID)
		if fetchErr == nil {
			return dbUserID, nil
		}
		return 0, fmt.Errorf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ %s ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: %w (‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°: %v)", discordID, fetchErr, err)
	}
	return dbUserID, nil
}

func generateAndSendQrCode(s *discordgo.Session, channelID string, promptPayNum string, amount float64, targetUserDiscordID string, description string, txID int) {
	payment := pp.PromptPay{PromptPayID: promptPayNum, Amount: amount}
	qrcodeStr, err := payment.Gen()
	if err != nil {
		sendErrorMessage(s, channelID, fmt.Sprintf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• QR ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s> ‡πÑ‡∏î‡πâ", targetUserDiscordID))
		log.Printf("Error generating PromptPay string for %s: %v", targetUserDiscordID, err)
		return
	}
	qrc, err := qrcode.New(qrcodeStr)
	if err != nil {
		sendErrorMessage(s, channelID, fmt.Sprintf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û QR ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s> ‡πÑ‡∏î‡πâ", targetUserDiscordID))
		log.Printf("Error generating QR code for %s: %v", targetUserDiscordID, err)
		return
	}
	filename := fmt.Sprintf("qr_%s_%d.jpg", targetUserDiscordID, time.Now().UnixNano())
	fileWriter, err := standard.New(filename)
	if err != nil {
		sendErrorMessage(s, channelID, fmt.Sprintf("‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û QR ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s> ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö", targetUserDiscordID))
		log.Printf("standard.New failed for QR %s: %v", targetUserDiscordID, err)
		return
	}
	if err = qrc.Save(fileWriter); err != nil {
		sendErrorMessage(s, channelID, fmt.Sprintf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û QR ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s> ‡πÑ‡∏î‡πâ", targetUserDiscordID))
		log.Printf("Could not save QR image for %s: %v", targetUserDiscordID, err)
		os.Remove(filename)
		return
	}
	file, err := os.Open(filename)
	if err != nil {
		sendErrorMessage(s, channelID, fmt.Sprintf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û QR ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s> ‡πÑ‡∏î‡πâ", targetUserDiscordID))
		log.Printf("Could not open QR image %s for sending: %v", filename, err)
		os.Remove(filename)
		return
	}
	defer file.Close()
	defer os.Remove(filename)

	txIDString := ""
	if txID > 0 {
		txIDString = fmt.Sprintf(" (TxID: %d)", txID)
	}

	msgContent := fmt.Sprintf("<@%s> ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ä‡∏≥‡∏£‡∏∞ %.2f ‡∏ö‡∏≤‡∏ó ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö \"%s\"%s\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏ô‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì", targetUserDiscordID, amount, description, txIDString)
	if description == "" {
		msgContent = fmt.Sprintf("<@%s> ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ä‡∏≥‡∏£‡∏∞ %.2f ‡∏ö‡∏≤‡∏ó%s\n‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏ô‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì", targetUserDiscordID, amount, txIDString)
	}

	_, err = s.ChannelFileSendWithMessage(channelID, msgContent, filename, file)
	if err != nil {
		log.Printf("Failed to send QR file for %s: %v", targetUserDiscordID, err)
	}
}

func handleBillStart(s *discordgo.Session, m *discordgo.MessageCreate) {
	activeBillsMutex.Lock()
	defer activeBillsMutex.Unlock()
	if _, exists := activeBills[m.ChannelID]; exists {
		sendErrorMessage(s, m.ChannelID, "‡∏°‡∏µ‡∏ö‡∏¥‡∏•‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡πÅ‡∏•‡πâ‡∏ß ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏ö‡∏¥‡∏•‡∏ô‡∏±‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢ `!bill finish`")
		return
	}
	args := strings.Fields(strings.ToLower(m.Content))
	var promptPayID string
	if len(args) > 2 {
		promptPayID = args[2]
		if !regexp.MustCompile(`^(\d{10}|\d{13}|ewallet-\d+)$`).MatchString(promptPayID) {
			sendErrorMessage(s, m.ChannelID, fmt.Sprintf("PromptPayID ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏ '%s' ‡∏î‡∏π‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏¥‡∏•‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏°‡∏µ PromptPayID", promptPayID))
			promptPayID = ""
		}
	}
	bill := &MultiItemBill{
		InitiatorID: m.Author.ID, ChannelID: m.ChannelID, PromptPayID: promptPayID,
		IsActive: true, Timestamp: time.Now(), Items: make([]BillItem, 0),
	}
	activeBills[m.ChannelID] = bill
	msgContent := "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏¥‡∏•‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏•‡πâ‡∏ß! "
	if promptPayID != "" {
		msgContent += fmt.Sprintf("PromptPay ID ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö QR code ‡∏Ñ‡∏∑‡∏≠: `%s`. ", promptPayID)
	} else {
		msgContent += "‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏∞‡∏ö‡∏∏ PromptPay ID, ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á QR code. "
	}
	msgContent += "‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö **‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ** ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: `<‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô> for <‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î> with @user1 @user2...`\n‡∏û‡∏¥‡∏°‡∏û‡πå `!bill finish` (‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö `!bill finish`) ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô"
	botMsg, err := s.ChannelMessageSend(m.ChannelID, msgContent)
	if err != nil {
		log.Printf("Failed to send bill start confirmation: %v", err)
		delete(activeBills, m.ChannelID)
		return
	}
	bill.MessageID = botMsg.ID
}

func handleBillFinish(s *discordgo.Session, m *discordgo.MessageCreate, bill *MultiItemBill) {
	activeBillsMutex.Lock()
	currentBill, ok := activeBills[m.ChannelID]
	if !ok || currentBill != bill || !bill.IsActive {
		activeBillsMutex.Unlock()
		sendErrorMessage(s, m.ChannelID, "‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏¥‡∏•‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏¢‡∏π‡πà ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏î‡πâ‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß")
		return
	}
	bill.IsActive = false
	activeBillsMutex.Unlock()

	defer func() {
		activeBillsMutex.Lock()
		delete(activeBills, m.ChannelID)
		activeBillsMutex.Unlock()
	}()

	if len(bill.Items) == 0 {
		s.ChannelMessageSend(m.ChannelID, "‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏ô‡∏ö‡∏¥‡∏• ‡∏ö‡∏¥‡∏•‡∏ñ‡∏π‡∏Å‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å")
		return
	}
	payeeDiscordID := bill.InitiatorID
	payeeDbID, err := getOrCreateDBUser(payeeDiscordID)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏¥‡∏• <@%s>", payeeDiscordID))
		return
	}
	userTotalDebts := make(map[string]float64)
	var summary strings.Builder
	summary.WriteString(fmt.Sprintf("‡∏™‡∏£‡∏∏‡∏õ‡∏ö‡∏¥‡∏•‡πÇ‡∏î‡∏¢ <@%s>:\n", bill.InitiatorID))
	totalBillAmount := 0.0
	for _, item := range bill.Items {
		totalBillAmount += item.Amount
		summary.WriteString(fmt.Sprintf("- `%.2f` ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö **%s**, ‡∏´‡∏≤‡∏£‡∏Å‡∏±‡∏ö: ", item.Amount, item.Description))
		for _, userID := range item.SharedWith {
			summary.WriteString(fmt.Sprintf("<@%s> ", userID))
		}
		summary.WriteString("\n")
		amountPerPerson := item.Amount / float64(len(item.SharedWith))
		for _, payerDiscordID := range item.SharedWith {
			userTotalDebts[payerDiscordID] += amountPerPerson
			_, dbErr := getOrCreateDBUser(payerDiscordID)
			if dbErr != nil {
				log.Printf("Error DB user %s for item '%s': %v", payerDiscordID, item.Description, dbErr)
				summary.WriteString(fmt.Sprintf("  (‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• <@%s> ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ)\n", payerDiscordID))
				continue
			}
		}
	}
	summary.WriteString(fmt.Sprintf("\n**‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏ö‡∏¥‡∏•: %.2f ‡∏ö‡∏≤‡∏ó**\n", totalBillAmount))
	summary.WriteString("\n‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á/‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï:\n")
	for payerDiscordID, totalOwed := range userTotalDebts {
		payerDbID, dbErr := getOrCreateDBUser(payerDiscordID)
		if dbErr != nil {
			summary.WriteString(fmt.Sprintf("- ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s>: ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•\n", payerDiscordID))
			continue
		}
		debtErr := updateUserDebt(payerDbID, payeeDbID, totalOwed)
		if debtErr != nil {
			summary.WriteString(fmt.Sprintf("- ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s> ‡∏ï‡πà‡∏≠ <@%s> ‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô %.2f.\n", payerDiscordID, payeeDiscordID, totalOwed))
		} else {
			summary.WriteString(fmt.Sprintf("- <@%s> ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏µ‡πâ <@%s> ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° **%.2f ‡∏ö‡∏≤‡∏ó** ‡∏à‡∏≤‡∏Å‡∏ö‡∏¥‡∏•‡∏ô‡∏µ‡πâ.\n", payerDiscordID, payeeDiscordID, totalOwed))
		}
		if bill.PromptPayID != "" && totalOwed > 0.009 {
			generateAndSendQrCode(s, m.ChannelID, bill.PromptPayID, totalOwed, payerDiscordID, "‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°‡∏à‡∏≤‡∏Å‡∏ö‡∏¥‡∏• "+bill.Timestamp.Format("2006-01-02"), 0)
		}
	}
	s.ChannelMessageSend(m.ChannelID, summary.String())
	log.Printf("Bill finished for channel %s by %s", m.ChannelID, m.Author.ID)
}

func handleSingleLineBill(s *discordgo.Session, m *discordgo.MessageCreate) {
	amount, description, mentions, promptPayID, err := parseSingleLineBillArgs(m.Content)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, err.Error())
		return
	}
	payeeDiscordID := m.Author.ID
	payeeDbID, err := getOrCreateDBUser(payeeDiscordID)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì (<@%s>)", payeeDiscordID))
		return
	}
	amountPerPerson := amount / float64(len(mentions))
	if amountPerPerson < 0.01 && amount > 0 {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ï‡πà‡∏≠‡∏Ñ‡∏ô (%.4f) ‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏¥‡∏•‡∏ô‡∏µ‡πâ (%.2f)", amountPerPerson, amount))
		return
	}

	var summary strings.Builder
	summary.WriteString(fmt.Sprintf("<@%s> ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏¥‡∏•‡∏à‡∏≥‡∏ô‡∏ß‡∏ô **%.2f ‡∏ö‡∏≤‡∏ó** ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö \"%s\", ‡∏´‡∏≤‡∏£‡∏Å‡∏±‡∏ö: ", m.Author.ID, amount, description))
	for _, userID := range mentions {
		summary.WriteString(fmt.Sprintf("<@%s> ", userID))
	}
	summary.WriteString(fmt.Sprintf("\n‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏à‡πà‡∏≤‡∏¢ **%.2f ‡∏ö‡∏≤‡∏ó**.\n", amountPerPerson))
	s.ChannelMessageSend(m.ChannelID, summary.String())

	for _, payerDiscordID := range mentions {
		payerDbID, dbErr := getOrCreateDBUser(payerDiscordID)
		if dbErr != nil {
			sendErrorMessage(s, m.ChannelID, fmt.Sprintf("- ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s> (DB user error).", payerDiscordID))
			continue
		}
		var txID int
		txErr := dbPool.QueryRow(context.Background(),
			`INSERT INTO transactions (payer_id, payee_id, amount, description) VALUES ($1, $2, $3, $4) RETURNING id`,
			payerDbID, payeeDbID, amountPerPerson, description).Scan(&txID)
		if txErr != nil {
			log.Printf("Failed to save transaction for user %s, bill '%s': %v", payerDiscordID, description, txErr)
			sendErrorMessage(s, m.ChannelID, fmt.Sprintf("- ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å transaction ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s>.", payerDiscordID))
			continue
		}

		debtErr := updateUserDebt(payerDbID, payeeDbID, amountPerPerson)
		if debtErr != nil {
			log.Printf("Failed to update debt for user %s, bill '%s': %v", payerDiscordID, description, debtErr)
			sendErrorMessage(s, m.ChannelID, fmt.Sprintf("- ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏¢‡∏≠‡∏î‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s>.", payerDiscordID))
		}

		if promptPayID != "" && amountPerPerson > 0.009 {
			generateAndSendQrCode(s, m.ChannelID, promptPayID, amountPerPerson, payerDiscordID, description, txID)
		}
	}
}

func handleQrCommand(s *discordgo.Session, m *discordgo.MessageCreate) {
	amount, toUserDiscordID, description, promptPayID, err := parseQrArgs(m.Content)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, err.Error())
		return
	}
	payeeDiscordID := m.Author.ID
	payeeDbID, err := getOrCreateDBUser(payeeDiscordID)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì (<@%s>)", payeeDiscordID))
		return
	}
	payerDbID, err := getOrCreateDBUser(toUserDiscordID)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö <@%s>", toUserDiscordID))
		return
	}

	var txID int
	err = dbPool.QueryRow(context.Background(),
		`INSERT INTO transactions (payer_id, payee_id, amount, description) VALUES ($1, $2, $3, $4) RETURNING id`,
		payerDbID, payeeDbID, amount, description).Scan(&txID)
	if err != nil {
		log.Printf("Failed to save transaction for !qr from %s to %s: %v", payeeDiscordID, toUserDiscordID, err)
		sendErrorMessage(s, m.ChannelID, "‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Transaction")
		return
	}

	err = updateUserDebt(payerDbID, payeeDbID, amount)
	if err != nil {
		log.Printf("Failed to update debt for !qr from %s to %s: %v", payeeDiscordID, toUserDiscordID, err)
	}

	generateAndSendQrCode(s, m.ChannelID, promptPayID, amount, toUserDiscordID, description, txID)
}

func handleRequestPayment(s *discordgo.Session, m *discordgo.MessageCreate) {
	debtorDiscordID, creditorPromptPayID, err := parseRequestPaymentArgs(m.Content)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, err.Error())
		return
	}

	creditorDiscordID := m.Author.ID

	if debtorDiscordID == creditorDiscordID {
		sendErrorMessage(s, m.ChannelID, "‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏≤‡∏Å‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡πÑ‡∏î‡πâ")
		return
	}
	debtorDbID, err := getOrCreateDBUser(debtorDiscordID)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏•‡∏π‡∏Å‡∏´‡∏ô‡∏µ‡πâ <@%s>", debtorDiscordID))
		return
	}
	creditorDbID, err := getOrCreateDBUser(creditorDiscordID)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Å‡∏±‡∏ö‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì (<@%s>)", creditorDiscordID))
		return
	}

	var debtAmount float64
	query := `SELECT amount FROM user_debts WHERE debtor_id = $1 AND creditor_id = $2`
	err = dbPool.QueryRow(context.Background(), query, debtorDbID, creditorDbID).Scan(&debtAmount)

	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏ó‡∏µ‡πà <@%s> ‡∏Ñ‡πâ‡∏≤‡∏á‡∏ä‡∏≥‡∏£‡∏∞‡∏Å‡∏±‡∏ö‡∏Ñ‡∏∏‡∏ì ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤", debtorDiscordID))
		log.Printf("Error querying debt for !request from creditor %s to debtor %s: %v", creditorDiscordID, debtorDiscordID, err)
		return
	}
	if debtAmount <= 0.009 {
		s.ChannelMessageSend(m.ChannelID, fmt.Sprintf("‡∏¢‡∏≠‡∏î‡πÄ‡∏¢‡∏µ‡πà‡∏¢‡∏°! <@%s> ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏¥‡∏î‡∏´‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∏‡∏ì‡∏≠‡∏¢‡∏π‡πà", debtorDiscordID))
		return
	}

	description := fmt.Sprintf("‡∏Ñ‡∏≥‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏ä‡∏≥‡∏£‡∏∞‡∏´‡∏ô‡∏µ‡πâ‡∏Ñ‡∏á‡∏Ñ‡πâ‡∏≤‡∏á‡∏à‡∏≤‡∏Å <@%s>", creditorDiscordID)
	generateAndSendQrCode(s, m.ChannelID, creditorPromptPayID, debtAmount, debtorDiscordID, description, 0)
}

func queryAndSendDebts(s *discordgo.Session, m *discordgo.MessageCreate, principalDiscordID string, mode string) {
	principalDbID, err := getOrCreateDBUser(principalDiscordID)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÑ‡∏°‡πà‡∏û‡∏ö <@%s> ‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•", principalDiscordID))
		return
	}
	var query, title string

	transactionDetailsSubquery := `
	WITH RankedTransactionDetails AS (
		SELECT
			t.payer_id,
			t.payee_id,
			t.description || ' (TxID:' || t.id::text || ')' as detail_text,
			ROW_NUMBER() OVER (PARTITION BY t.payer_id, t.payee_id ORDER BY t.created_at DESC, t.id DESC) as rn
		FROM transactions t
		WHERE t.already_paid = false
	)
	SELECT
		rtd.payer_id,
		rtd.payee_id,
		STRING_AGG(rtd.detail_text, '; ' ORDER BY rtd.rn) as details
	FROM RankedTransactionDetails rtd
	GROUP BY rtd.payer_id, rtd.payee_id
	`
	if mode == "debtor" {
		title = fmt.Sprintf("‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á <@%s> (‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏à‡πà‡∏≤‡∏¢‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô):\n", principalDiscordID)
		query = fmt.Sprintf(`
            SELECT ud.amount, u_other.discord_id AS other_party_discord_id,
                   COALESCE(tx_details.details, '‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏£‡∏ß‡∏° ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ä‡∏≥‡∏£‡∏∞‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á') as details
            FROM user_debts ud
            JOIN users u_other ON ud.creditor_id = u_other.id
            LEFT JOIN (
                %s
            ) AS tx_details ON tx_details.payer_id = ud.debtor_id AND tx_details.payee_id = ud.creditor_id
            WHERE ud.debtor_id = $1 AND ud.amount > 0.009
            ORDER BY ud.amount DESC;`, transactionDetailsSubquery)
	} else {
		title = fmt.Sprintf("‡∏¢‡∏≠‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡∏ä‡∏≥‡∏£‡∏∞‡∏ñ‡∏∂‡∏á <@%s> (‡∏ó‡∏µ‡πà‡∏Ñ‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏à‡πà‡∏≤‡∏¢):\n", principalDiscordID)
		query = fmt.Sprintf(`
            SELECT ud.amount, u_other.discord_id AS other_party_discord_id,
                   COALESCE(tx_details.details, '‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏£‡∏ß‡∏° ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ä‡∏≥‡∏£‡∏∞‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á') as details
            FROM user_debts ud
            JOIN users u_other ON ud.debtor_id = u_other.id
            LEFT JOIN (
                %s
            ) AS tx_details ON tx_details.payer_id = ud.debtor_id AND tx_details.payee_id = ud.creditor_id
            WHERE ud.creditor_id = $1 AND ud.amount > 0.009
            ORDER BY ud.amount DESC;`, transactionDetailsSubquery)
	}

	rows, err := dbPool.Query(context.Background(), query, principalDbID)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡πÑ‡∏î‡πâ")
		log.Printf("Error querying debts (mode: %s) for %s (dbID %d): %v\n--- Query Start ---\n%s\n--- Query End ---", mode, principalDiscordID, principalDbID, err, query)
		return
	}
	defer rows.Close()

	var response strings.Builder
	response.WriteString(title)
	count := 0
	for rows.Next() {
		var amount float64
		var otherPartyDiscordID, details string
		if err := rows.Scan(&amount, &otherPartyDiscordID, &details); err != nil {
			log.Printf("Failed to scan debt row (mode: %s): %v", mode, err)
			continue
		}
		maxDetailLen := 150
		if len(details) > maxDetailLen {
			details = details[:maxDetailLen-3] + "..."
		}
		if mode == "debtor" {
			response.WriteString(fmt.Sprintf("- **%.2f ‡∏ö‡∏≤‡∏ó** ‡πÉ‡∏´‡πâ <@%s> (‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: %s)\n", amount, otherPartyDiscordID, details))
		} else {
			response.WriteString(fmt.Sprintf("- <@%s> ‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏µ‡πâ **%.2f ‡∏ö‡∏≤‡∏ó** (‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î: %s)\n", otherPartyDiscordID, amount, details))
		}
		count++
	}

	if count == 0 {
		if mode == "debtor" {
			response.WriteString(fmt.Sprintf("<@%s> ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏á‡∏ä‡∏≥‡∏£‡∏∞! üéâ\n", principalDiscordID))
		} else {
			response.WriteString(fmt.Sprintf("‡∏î‡∏π‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ß‡πà‡∏≤‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡∏à‡∏∞‡∏ä‡∏≥‡∏£‡∏∞‡∏´‡∏ô‡∏µ‡πâ‡πÉ‡∏´‡πâ <@%s> ‡∏´‡∏°‡∏î‡πÅ‡∏•‡πâ‡∏ß üëç\n", principalDiscordID))
		}
	}
	s.ChannelMessageSend(m.ChannelID, response.String())
}

func handleMyDebts(s *discordgo.Session, m *discordgo.MessageCreate) {
	queryAndSendDebts(s, m, m.Author.ID, "debtor")
}
func handleOwedToMe(s *discordgo.Session, m *discordgo.MessageCreate) {
	queryAndSendDebts(s, m, m.Author.ID, "creditor")
}
func handleDebtsOfUser(s *discordgo.Session, m *discordgo.MessageCreate, args []string) {
	if len(args) == 0 || !userMentionRegex.MatchString(args[0]) {
		sendErrorMessage(s, m.ChannelID, "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ `!debts @user`")
		return
	}
	targetUserDiscordID := userMentionRegex.FindStringSubmatch(args[0])[1]
	queryAndSendDebts(s, m, targetUserDiscordID, "debtor")
}
func handleDuesForUser(s *discordgo.Session, m *discordgo.MessageCreate, args []string) {
	if len(args) == 0 || !userMentionRegex.MatchString(args[0]) {
		sendErrorMessage(s, m.ChannelID, "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ `!dues @user`")
		return
	}
	targetUserDiscordID := userMentionRegex.FindStringSubmatch(args[0])[1]
	queryAndSendDebts(s, m, targetUserDiscordID, "creditor")
}

func handleHelpCommand(s *discordgo.Session, m *discordgo.MessageCreate, args []string) {
	baseHelp := `
**PaySplitter Bot - ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**
‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ‡∏û‡∏¥‡∏°‡∏û‡πå ` + "`!help <‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á>`" + `

- ` + "`!bill`" + `: ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏•‡∏∞‡∏´‡∏≤‡∏£‡∏ö‡∏¥‡∏•
- ` + "`!qr`" + `: ‡∏™‡∏£‡πâ‡∏≤‡∏á QR code ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£
- ` + "`!mydebts`" + `: ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏à‡πà‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡∏≠‡∏∑‡πà‡∏ô
- ` + "`!owedtome`" + ` (‡∏´‡∏£‡∏∑‡∏≠ ` + "`!mydues`" + `): ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡∏≠‡∏∑‡πà‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∏‡∏ì
- ` + "`!debts @user`" + `: ‡πÅ‡∏™‡∏î‡∏á‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á @user ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
- ` + "`!dues @user`" + `: ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡∏≠‡∏∑‡πà‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏µ‡πâ @user ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
- ` + "`!paid <TxID>`" + `: ‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏° (TxID) ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÅ‡∏•‡πâ‡∏ß
- ` + "`!request @user <PromptPayID>`" + `: ‡∏™‡∏£‡πâ‡∏≤‡∏á QR code ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡πÉ‡∏´‡πâ @user ‡∏ä‡∏≥‡∏£‡∏∞‡∏´‡∏ô‡∏µ‡πâ‡∏Ñ‡∏á‡∏Ñ‡πâ‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì
- ` + "`!help`" + `: ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏ô‡∏µ‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞

**‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥:**
‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° QR code ‡∏à‡∏≤‡∏Å‡∏ö‡∏≠‡∏ó‡∏ô‡∏µ‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏ô‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
`

	billHelp := `
**‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ` + "`!bill`" + ` - ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**

1.  **‡∏ö‡∏¥‡∏•‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏µ‡∏¢‡∏ß / ‡∏´‡∏≤‡∏£‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢:**
    ` + "`!bill <‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô> for <‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î> with @user1 @user2... [YourPromptPayID]`" + `
    - ‡∏´‡∏≤‡∏£ ` + "`<‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô>`" + ` ‡πÄ‡∏ó‡πà‡∏≤‡πÜ ‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏Å‡∏•‡πà‡∏≤‡∏ß‡∏ñ‡∏∂‡∏á ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ` + "`<‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î>`" + ` ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
    - ` + "`[YourPromptPayID]`" + ` (‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏¢‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì) ‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà ‡∏´‡∏≤‡∏Å‡πÉ‡∏™‡πà ‡∏à‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á QR code ‡πÉ‡∏´‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô
    - ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á (‡∏û‡∏£‡πâ‡∏≠‡∏° QR): ` + "`!bill 300 for ‡∏Ñ‡πà‡∏≤‡∏ï‡∏±‡πã‡∏ß‡∏´‡∏ô‡∏±‡∏á with @Alice @Bob 0812345678`" + `
    - ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á (‡πÑ‡∏°‡πà‡∏°‡∏µ QR, ‡πÅ‡∏Ñ‡πà‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏´‡∏ô‡∏µ‡πâ): ` + "`!bill 150 for ‡∏Ñ‡πà‡∏≤‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏Å‡∏•‡∏≤‡∏á‡∏ß‡∏±‡∏ô with @Charlie`" + `

2.  **‡∏ö‡∏¥‡∏•‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£:**
    a. ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏¥‡∏•: ` + "`!bill start [YourPromptPayID]`" + `
       - ` + "`[YourPromptPayID]`" + ` ‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà ‡∏´‡∏≤‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á QR code
       - ‡∏ö‡∏≠‡∏ó‡∏à‡∏∞‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
    b. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£: ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ó‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö:
       ` + "`<‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô> for <‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£> with @user1 @user2...`" + `
       - ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£: ` + "`100 for ‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏ã‡∏ã‡πà‡∏≤ with @Alice @Bob`" + `
       - ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ï‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
    c. ‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏ö‡∏¥‡∏•: ` + "`!bill finish`" + ` (‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö ` + "`!bill finish`" + ` ‡∏ó‡∏µ‡πà‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ö‡∏¥‡∏•‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ó)
       - ‡∏ö‡∏≠‡∏ó‡∏à‡∏∞‡∏™‡∏£‡∏∏‡∏õ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á QR code ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏∏ PromptPayID ‡πÑ‡∏ß‡πâ
`
	qrHelp := `
**‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ` + "`!qr`" + ` - ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**

‡∏™‡∏£‡πâ‡∏≤‡∏á QR code ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏ ‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì
‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: ` + "`!qr <‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô> to @user for <‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î> <YourPromptPayID>`" + `
- ` + "`<‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô>`" + `: ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πâ‡∏≠‡∏á‡∏ä‡∏≥‡∏£‡∏∞
- ` + "`@user`" + `: ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì
- ` + "`<‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î>`" + `: ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô
- ` + "`<YourPromptPayID>`" + `: ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏¢‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì (‡πÄ‡∏ö‡∏≠‡∏£‡πå‡πÇ‡∏ó‡∏£‡∏®‡∏±‡∏û‡∏ó‡πå, ‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ï‡∏£‡∏õ‡∏£‡∏∞‡∏ä‡∏≤‡∏ä‡∏ô, ‡∏´‡∏£‡∏∑‡∏≠ ewallet-id) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö QR code (‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà)

‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: ` + "`!qr 75 to @Eve for ‡∏´‡∏ô‡∏µ‡πâ‡πÄ‡∏Å‡πà‡∏≤ 0888777666`" + `
‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏à‡∏≤‡∏Å @Eve ‡∏ñ‡∏∂‡∏á‡∏Ñ‡∏∏‡∏ì‡∏î‡πâ‡∏ß‡∏¢
`
	debtsHelp := `
**‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏î‡∏π‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô - ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**

- ` + "`!mydebts`" + `: ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏µ‡πâ ‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°
- ` + "`!owedtome`" + ` (‡∏´‡∏£‡∏∑‡∏≠ ` + "`!mydues`" + `): ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏´‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∏‡∏ì ‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏ô ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°
- ` + "`!debts @user`" + `: ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤ ` + "`@user`" + ` ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏µ‡πâ‡πÉ‡∏Ñ‡∏£‡∏ö‡πâ‡∏≤‡∏á
- ` + "`!dues @user`" + `: ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡πÉ‡∏Ñ‡∏£‡∏ö‡πâ‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏´‡∏ô‡∏µ‡πâ ` + "`@user`" + ` ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏

‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏° (TxID) ‡∏à‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡∏∂‡πâ‡∏ô ‡∏ã‡∏∂‡πà‡∏á‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ` + "`!paid`" + ` ‡πÑ‡∏î‡πâ
`

	paidHelp := `
**‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ` + "`!paid`" + ` - ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**

‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏ß‡πà‡∏≤‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÅ‡∏•‡πâ‡∏ß ‡πÇ‡∏î‡∏¢‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡∏ó‡∏µ‡πà *‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö* ‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô
‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: ` + "`!paid <TxID1>[,<TxID2>,...]`" + `
- ` + "`<TxID>`" + `: ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏Ç‡∏≠‡∏á‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏π TxID ‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ` + "`!mydebts`" + ` ‡∏´‡∏£‡∏∑‡∏≠ ` + "`!owedtome`" + `
- ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏´‡∏•‡∏≤‡∏¢‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ‡πÇ‡∏î‡∏¢‡∏Ñ‡∏±‡πà‡∏ô TxID ‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏à‡∏∏‡∏•‡∏†‡∏≤‡∏Ñ (,) ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ß‡πâ‡∏ô‡∏ß‡∏£‡∏£‡∏Ñ

‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á (‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏µ‡∏¢‡∏ß): ` + "`!paid 123`" + `
‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á (‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£): ` + "`!paid 123,124,125`" + `

‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ò‡∏∏‡∏£‡∏Å‡∏£‡∏£‡∏°‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏¢‡∏≠‡∏î‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏£‡∏ß‡∏°‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
‡∏≠‡∏µ‡∏Å‡∏ó‡∏≤‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ú‡∏π‡πâ‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏Ñ‡∏∑‡∏≠ ‡∏Å‡∏≤‡∏£‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° QR code ‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ó‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏ô‡∏ö‡∏™‡∏•‡∏¥‡∏õ ‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏ä‡∏≥‡∏£‡∏∞‡πÅ‡∏•‡πâ‡∏ß‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
`
	requestPaymentHelp := `
**‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ` + "`!request`" + ` - ‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**

‡∏™‡∏£‡πâ‡∏≤‡∏á QR code ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏≠‡∏∑‡πà‡∏ô‡∏ä‡∏≥‡∏£‡∏∞‡∏´‡∏ô‡∏µ‡πâ‡∏Ñ‡∏á‡∏Ñ‡πâ‡∏≤‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡∏≤‡∏°‡∏µ‡∏ï‡πà‡∏≠‡∏Ñ‡∏∏‡∏ì
‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: ` + "`!request @‡∏•‡∏π‡∏Å‡∏´‡∏ô‡∏µ‡πâ <PromptPayID‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì>`" + `
- ` + "`@‡∏•‡∏π‡∏Å‡∏´‡∏ô‡∏µ‡πâ`" + `: ‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡πÉ‡∏´‡πâ‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô
- ` + "`<PromptPayID‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì>`" + `: ‡∏Ñ‡∏∑‡∏≠‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏¢‡πå *‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì* (‡∏ú‡∏π‡πâ‡∏£‡πâ‡∏≠‡∏á‡∏Ç‡∏≠) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏•‡∏π‡∏Å‡∏´‡∏ô‡∏µ‡πâ‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡∏°‡∏≤
- ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏î‡∏∂‡∏á‡∏°‡∏≤‡∏à‡∏≤‡∏Å‡∏¢‡∏≠‡∏î‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏•‡∏π‡∏Å‡∏´‡∏ô‡∏µ‡πâ‡∏Ñ‡πâ‡∏≤‡∏á‡∏Ñ‡∏∏‡∏ì‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥

‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: ` + "`!request @Alice 081xxxxxxx`" + ` (‡∏ö‡∏≠‡∏ó‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á QR ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏≠‡∏î‡∏´‡∏ô‡∏µ‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà @Alice ‡∏Ñ‡πâ‡∏≤‡∏á‡∏Ñ‡∏∏‡∏ì ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏¢‡πå 081xxxxxxx ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì)
`

	if len(args) > 1 {
		topic := strings.ToLower(args[1])
		var helpMsg string
		switch topic {
		case "bill":
			helpMsg = billHelp
		case "qr":
			helpMsg = qrHelp
		case "mydebts", "owedtome", "mydues", "debts", "dues":
			helpMsg = debtsHelp
		case "paid":
			helpMsg = paidHelp
		case "request":
			helpMsg = requestPaymentHelp
		default:
			helpMsg = "‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢ ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠ `" + topic + "` ‡∏•‡∏≠‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå `!help` ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏´‡∏•‡∏±‡∏Å"
		}
		s.ChannelMessageSend(m.ChannelID, helpMsg)
	} else {
		s.ChannelMessageSend(m.ChannelID, baseHelp)
	}
}

func handleSlipVerification(s *discordgo.Session, m *discordgo.MessageCreate) {
	if m.MessageReference == nil || m.MessageReference.MessageID == "" || len(m.Attachments) == 0 {
		return
	}
	refMsg, err := s.ChannelMessage(m.ChannelID, m.MessageReference.MessageID)
	if err != nil {
		log.Printf("SlipVerify: Error fetching referenced message %s: %v", m.MessageReference.MessageID, err)
		return
	}
	if refMsg.Author == nil || refMsg.Author.ID != s.State.User.ID {
		return
	}
	parsedDebtorDiscordID, parsedAmount, parsedTxID, err := parseBotQRMessageContent(refMsg.Content)
	if err != nil {
		return
	}
	log.Printf("SlipVerify: Received slip verification for debtor %s, amount %s, TxID %s", parsedDebtorDiscordID, parsedAmount, parsedTxID)
	slipUploaderID := m.Author.ID
	var slipURL string
	for _, att := range m.Attachments {
		if strings.HasPrefix(strings.ToLower(att.ContentType), "image/") {
			slipURL = att.URL
			break
		}
	}
	if slipURL == "" {
		return
	}

	if slipUploaderID != parsedDebtorDiscordID {
		log.Printf("SlipVerify: Slip uploaded by %s for debtor %s - ignoring.", slipUploaderID, parsedDebtorDiscordID)
		return
	}

	tmpFile := fmt.Sprintf("slip_%s_%s.png", m.ID, parsedDebtorDiscordID)
	err = DownloadFile(tmpFile, slipURL)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÑ‡∏î‡πâ")
		log.Printf("SlipVerify: Failed to download slip %s: %v", slipURL, err)
		return
	}
	defer os.Remove(tmpFile)

	verifyResp, err := VerifySlip(parsedAmount, tmpFile)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å API ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: %v", err))
		log.Printf("SlipVerify: API call failed for debtor %s, amount %.2f: %v", parsedDebtorDiscordID, parsedAmount, err)
		return
	}

	if !(verifyResp.Data.Amount > parsedAmount-0.01 && verifyResp.Data.Amount < parsedAmount+0.01) {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏™‡∏•‡∏¥‡∏õ (%.2f) ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏≤‡∏î‡πÑ‡∏ß‡πâ (%.2f)", verifyResp.Data.Amount, parsedAmount))
		return
	}

	if parsedTxID > 0 {
		log.Printf("SlipVerify: Attempting direct update using TxID: %d", parsedTxID)
		err = markTransactionPaidAndUpdateDebt(parsedTxID)
		if err == nil {
			var intendedPayeeDiscordID string
			payeeDbID, fetchErr := getPayeeDbIdFromTx(parsedTxID)
			if fetchErr == nil {
				intendedPayeeDiscordID, _ = getDiscordIdFromDbId(payeeDbID)
			}
			if intendedPayeeDiscordID == "" {
				intendedPayeeDiscordID = "???"
			}

			s.ChannelMessageSend(m.ChannelID, fmt.Sprintf(
				"‚úÖ ‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô & ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß (TxID: %d)!\n- ‡∏ú‡∏π‡πâ‡∏à‡πà‡∏≤‡∏¢: <@%s>\n- ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö: <@%s>\n- ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô: %.2f ‡∏ö‡∏≤‡∏ó\n- ‡∏ú‡∏π‡πâ‡∏™‡πà‡∏á (‡∏™‡∏•‡∏¥‡∏õ): %s (%s)\n- ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö (‡∏™‡∏•‡∏¥‡∏õ): %s (%s)\n- ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà (‡∏™‡∏•‡∏¥‡∏õ): %s\n- ‡πÄ‡∏•‡∏Ç‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á (‡∏™‡∏•‡∏¥‡∏õ): %s",
				parsedTxID, parsedDebtorDiscordID, intendedPayeeDiscordID, parsedAmount,
				verifyResp.Data.SenderName, verifyResp.Data.SenderID,
				verifyResp.Data.ReceiverName, verifyResp.Data.ReceiverID,
				verifyResp.Data.Date, verifyResp.Data.Ref,
			))
			return
		}
		log.Printf("SlipVerify: Failed direct update using TxID %d (possibly already paid?): %v. Falling back to general debt reduction.", parsedTxID, err)
	}

	log.Printf("SlipVerify: No TxID found or direct update failed. Attempting general debt reduction for %s paying amount %.2f.", parsedDebtorDiscordID, parsedAmount)
	intendedPayeeDiscordID, err := findIntendedPayee(parsedDebtorDiscordID, parsedAmount)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ: %v", err))
		log.Printf("SlipVerify: Could not determine intended payee for debtor %s, amount %.2f: %v", parsedDebtorDiscordID, parsedAmount, err)
		return
	}

	errReduce := reduceDebtFromPayment(parsedDebtorDiscordID, intendedPayeeDiscordID, parsedAmount)
	if errReduce != nil {
		sendErrorMessage(s, m.ChannelID, fmt.Sprintf("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡∏î‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö <@%s> ‡∏ñ‡∏∂‡∏á <@%s>: %v", parsedDebtorDiscordID, intendedPayeeDiscordID, errReduce))
		log.Printf("SlipVerify: Failed general debt reduction for %s to %s (%.2f): %v", parsedDebtorDiscordID, intendedPayeeDiscordID, parsedAmount, errReduce)
		return
	}
	s.ChannelMessageSend(m.ChannelID, fmt.Sprintf(
		"‚úÖ ‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô & ‡∏¢‡∏≠‡∏î‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏à‡∏≤‡∏Å <@%s> ‡∏ñ‡∏∂‡∏á <@%s> ‡∏•‡∏î‡∏•‡∏á %.2f ‡∏ö‡∏≤‡∏ó!\n- ‡∏ú‡∏π‡πâ‡∏™‡πà‡∏á (‡∏™‡∏•‡∏¥‡∏õ): %s (%s)\n- ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö (‡∏™‡∏•‡∏¥‡∏õ): %s (%s)\n- ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà (‡∏™‡∏•‡∏¥‡∏õ): %s\n- ‡πÄ‡∏•‡∏Ç‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á (‡∏™‡∏•‡∏¥‡∏õ): %s",
		parsedDebtorDiscordID, intendedPayeeDiscordID, parsedAmount,
		verifyResp.Data.SenderName, verifyResp.Data.SenderID,
		verifyResp.Data.ReceiverName, verifyResp.Data.ReceiverID,
		verifyResp.Data.Date, verifyResp.Data.Ref,
	))
}

func getPayeeDbIdFromTx(txID int) (int, error) {
	var payeeDbID int
	query := `SELECT payee_id FROM transactions WHERE id = $1`
	err := dbPool.QueryRow(context.Background(), query, txID).Scan(&payeeDbID)
	if err != nil {
		log.Printf("Error fetching payee DB ID for TxID %d: %v", txID, err)
		return 0, err
	}
	return payeeDbID, nil
}

func getDiscordIdFromDbId(dbUserID int) (string, error) {
	var discordID string
	query := `SELECT discord_id FROM users WHERE id = $1`
	err := dbPool.QueryRow(context.Background(), query, dbUserID).Scan(&discordID)
	if err != nil {
		log.Printf("Error fetching Discord ID for DB User ID %d: %v", dbUserID, err)
		return "", err
	}
	return discordID, nil
}

func findIntendedPayee(debtorDiscordID string, amount float64) (string, error) {
	debtorDbID, err := getOrCreateDBUser(debtorDiscordID)
	if err != nil {
		return "", fmt.Errorf("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡∏à‡πà‡∏≤‡∏¢‡πÄ‡∏á‡∏¥‡∏ô %s ‡πÉ‡∏ô DB: %w", debtorDiscordID, err)
	}

	var payeeDiscordID string
	var count int
	query := `
		SELECT u.discord_id, COUNT(*) OVER()
		FROM user_debts ud
		JOIN users u ON ud.creditor_id = u.id
		WHERE ud.debtor_id = $1
		  AND ABS(ud.amount - $2::numeric) < 0.01
		  AND ud.amount > 0.009
		LIMIT 1;
	`
	err = dbPool.QueryRow(context.Background(), query, debtorDbID, amount).Scan(&payeeDiscordID, &count)
	if err == nil && count == 1 {
		log.Printf("findIntendedPayee: Found single matching creditor %s based on total debt amount %.2f for debtor %s", payeeDiscordID, amount, debtorDiscordID)
		return payeeDiscordID, nil
	}
	if err == nil && count > 1 {
		log.Printf("findIntendedPayee: Ambiguous - Debtor %s owes %.2f to multiple creditors.", debtorDiscordID, amount)
	}

	query = `
		SELECT u.discord_id, COUNT(*) OVER() as payee_count
		FROM transactions t
		JOIN users u ON t.payee_id = u.id
		WHERE t.payer_id = $1
		  AND ABS(t.amount - $2::numeric) < 0.01
		  AND t.already_paid = false
		GROUP BY u.discord_id
		LIMIT 2;
	`
	rows, err := dbPool.Query(context.Background(), query, debtorDbID, amount)
	if err != nil {
		log.Printf("findIntendedPayee: Error querying transactions for debtor %s amount %.2f: %v", debtorDiscordID, amount, err)
		return "", fmt.Errorf("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô")
	}
	defer rows.Close()

	var potentialPayees []string
	for rows.Next() {
		var payee string
		if err := rows.Scan(&payee, &count); err != nil {
			log.Printf("findIntendedPayee: Error scanning transaction row: %v", err)
			continue
		}
		potentialPayees = append(potentialPayees, payee)
	}

	if len(potentialPayees) == 1 {
		log.Printf("findIntendedPayee: Found single matching payee %s based on transaction amount %.2f for debtor %s", potentialPayees[0], amount, debtorDiscordID)
		return potentialPayees[0], nil
	}

	if len(potentialPayees) > 1 {
		log.Printf("findIntendedPayee: Ambiguous - Found multiple potential payees based on transaction amount %.2f for debtor %s", amount, debtorDiscordID)
		return "", fmt.Errorf("‡∏û‡∏ö‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ô‡∏µ‡πâ ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á `!paid <TxID>` ‡πÇ‡∏î‡∏¢‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô")
	}

	log.Printf("findIntendedPayee: Could not determine unique intended payee for debtor %s, amount %.2f", debtorDiscordID, amount)
	return "", fmt.Errorf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏¢‡∏≠‡∏î‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏î‡πâ‡∏ß‡∏¢ `!paid <TxID>`")
}

func reduceDebtFromPayment(debtorDiscordID, payeeDiscordID string, amount float64) error {
	debtorDbID, err := getOrCreateDBUser(debtorDiscordID)
	if err != nil {
		return fmt.Errorf("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡∏à‡πà‡∏≤‡∏¢‡πÄ‡∏á‡∏¥‡∏ô %s ‡πÉ‡∏ô DB: %w", debtorDiscordID, err)
	}
	payeeDbID, err := getOrCreateDBUser(payeeDiscordID)
	if err != nil {
		return fmt.Errorf("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô %s ‡πÉ‡∏ô DB: %w", payeeDiscordID, err)
	}

	tx, err := dbPool.Begin(context.Background())
	if err != nil {
		return fmt.Errorf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏° Transaction ‡πÑ‡∏î‡πâ: %w", err)
	}
	defer tx.Rollback(context.Background())

	result, err := tx.Exec(context.Background(),
		`UPDATE user_debts SET amount = amount - $1, updated_at = CURRENT_TIMESTAMP
         WHERE debtor_id = $2 AND creditor_id = $3 AND amount > 0.009`,
		amount, debtorDbID, payeeDbID)

	if err != nil {
		return fmt.Errorf("‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ç‡∏ì‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏´‡∏ô‡∏µ‡πâ‡∏™‡∏¥‡∏ô‡∏£‡∏ß‡∏°: %w", err)
	}

	rowsAffected := result.RowsAffected()
	if rowsAffected == 0 {
		log.Printf("Debt reduction update affected 0 rows for debtor %d paying creditor %d amount %.2f. Debt might be zero or negative already.", debtorDbID, payeeDbID, amount)
		zeroResult, errZero := tx.Exec(context.Background(),
			`UPDATE user_debts SET amount = 0, updated_at = CURRENT_TIMESTAMP
		   WHERE debtor_id = $1 AND creditor_id = $2 AND amount > 0.009 AND amount < $3`,
			debtorDbID, payeeDbID, amount)
		if errZero != nil {
			log.Printf("Warning/Error trying to zero out remaining debt for debtor %d creditor %d amount %.2f: %v", debtorDbID, payeeDbID, amount, errZero)
		} else if zeroResult.RowsAffected() > 0 {
			log.Printf("Zeroed out remaining debt for debtor %d paying creditor %d (Payment %.2f)", debtorDbID, payeeDbID, amount)
		}
	}

	if err = tx.Commit(context.Background()); err != nil {
		return fmt.Errorf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ Commit Transaction ‡πÑ‡∏î‡πâ: %w", err)
	}

	log.Printf("General debt reduction successful: Debtor %d, Creditor %d, Amount %.2f", debtorDbID, payeeDbID, amount)
	return nil
}

func parseBotQRMessageContent(content string) (debtorDiscordID string, amount float64, txID int, err error) {
	re := regexp.MustCompile(`<@!?(\d+)> ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ä‡∏≥‡∏£‡∏∞ ([\d.]+) ‡∏ö‡∏≤‡∏ó`)
	matches := re.FindStringSubmatch(content)
	if len(matches) < 3 {
		return "", 0, 0, fmt.Errorf("‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° QR ‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ó")
	}

	debtorDiscordID = matches[1]
	parsedAmount, parseErr := strconv.ParseFloat(matches[2], 64)
	if parseErr != nil {
		return "", 0, 0, fmt.Errorf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏¢‡∏Å‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° QR ‡∏Ç‡∏≠‡∏á‡∏ö‡∏≠‡∏ó: %v", parseErr)
	}
	amount = parsedAmount

	txMatch := txIDRegex.FindStringSubmatch(content)
	if len(txMatch) == 2 {
		parsedTxID, txErr := strconv.Atoi(txMatch[1])
		if txErr == nil {
			txID = parsedTxID
		} else {
			log.Printf("Warning: Failed to parse TxID '%s' from QR message: %v", txMatch[1], txErr)
		}
	}

	return debtorDiscordID, amount, txID, nil
}

func DiscordConnect() (err error) {
	dg, err = discordgo.New("Bot " + viper.GetString("DiscordBot.Token"))
	if err != nil {
		log.Println("FATAL: error creating Discord session,", err)
		return
	}
	dg.Identify.Intents = discordgo.IntentsGuildMessages | discordgo.IntentsGuildMessageReactions | discordgo.IntentsMessageContent

	log.Println("INFO: ‡∏ö‡∏≠‡∏ó‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏õ‡∏¥‡∏î...")
	dg.AddHandler(messageHandler)
	err = dg.Open()
	if err != nil {
		log.Println("FATAL: Error Open():", err)
		return
	}
	_, err = dg.User("@me")
	if err != nil {
		log.Println("FATAL: Login unsuccessful:", err)
		return
	}
	log.Println("INFO: ‡∏ö‡∏≠‡∏ó‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô ‡∏Å‡∏î CTRL-C ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏Å")
	return nil
}

func init() {
	viper.SetConfigName("config")
	viper.AddConfigPath(".")
	viper.AutomaticEnv()

	if err := viper.ReadInConfig(); err != nil {
		if _, ok := err.(viper.ConfigFileNotFoundError); ok {
			log.Println("‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå config, ‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏ß‡∏î‡∏•‡πâ‡∏≠‡∏°")
		} else {
			log.Fatalf("CRITICAL: ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡πà‡∏≤‡∏ô config: %v\n", err)
		}
	} else {
		log.Println("‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡πÑ‡∏ü‡∏•‡πå config:", viper.ConfigFileUsed())
	}

	viper.SetDefault("DiscordBot.Token", "")
	viper.SetDefault("PostgreSQL.Host", "localhost")
	viper.SetDefault("PostgreSQL.Port", "5432")
	viper.SetDefault("PostgreSQL.User", "postgres")
	viper.SetDefault("PostgreSQL.Password", "")
	viper.SetDefault("PostgreSQL.DBName", "discordbotdb")
	viper.SetDefault("PostgreSQL.Schema", "public")
	viper.SetDefault("PostgreSQL.PoolMaxConns", 10)
}

func main() {
	initPostgresPool()
	if dbPool != nil {
		defer dbPool.Close()
	} else {
		log.Fatal("CRITICAL: dbPool is nil after initPostgresPool. Exiting.")
	}

	migrateDatabase()

	err := DiscordConnect()
	if err != nil {
		log.Fatalf("CRITICAL: Failed to connect to Discord: %v", err)
	}
	<-make(chan struct{})
}

type VerifySlipResponse struct {
	Message string `json:"message"`
	Data    struct {
		Ref          string  `json:"ref"`
		Date         string  `json:"date"`
		SenderBank   string  `json:"sender_bank"`
		SenderName   string  `json:"sender_name"`
		SenderID     string  `json:"sender_id"`
		ReceiverBank string  `json:"receiver_bank"`
		ReceiverName string  `json:"receiver_name"`
		ReceiverID   string  `json:"receiver_id"`
		Amount       float64 `json:"amount"`
	} `json:"data"`
}

func DownloadFile(filepath string, url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("http.Get failed for %s: %w", url, err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("bad status: %s for %s", resp.Status, url)
	}

	out, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("os.Create failed for %s: %w", filepath, err)
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return fmt.Errorf("io.Copy failed for %s: %w", filepath, err)
	}
	log.Printf("Downloaded file from %s to %s", url, filepath)
	return nil
}

func VerifySlip(amount float64, imgPath string) (*VerifySlipResponse, error) {
	log.Printf("VerifySlip called for amount %.2f, image %s", amount, imgPath)

	imgBytes, err := os.ReadFile(imgPath)
	if err != nil {
		return nil, fmt.Errorf("VerifySlip: failed to read image file: %v", err)
	}
	imgBase64 := base64.StdEncoding.EncodeToString(imgBytes)
	payload := map[string]string{
		"img": fmt.Sprintf("data:image/png;base64,%s", imgBase64),
	}
	jsonData, err := json.Marshal(payload)
	if err != nil {
		return nil, fmt.Errorf("VerifySlip: failed to marshal JSON: %v", err)
	}
	url := fmt.Sprintf("https://slip-c.oiioioiiioooioio.download/api/slip/%.2f", amount)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("VerifySlip: failed to create request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		},
		Timeout: 20 * time.Second,
	}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("VerifySlip: failed to send request: %v", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("VerifySlip: failed to read response: %v", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("VerifySlip: API returned status %d. Body: %s", resp.StatusCode, string(body))
	}

	var result VerifySlipResponse
	if err := json.Unmarshal(body, &result); err != nil {
		return nil, fmt.Errorf("VerifySlip: failed to unmarshal response: %v, body: %s", err, string(body))
	}
	log.Printf("VerifySlip successful for amount %.2f. API Response Ref: %s", amount, result.Data.Ref)
	return &result, nil
}

func findMatchingTransaction(payerDiscordID, payeeDiscordID string, amount float64) (int, error) {
	var payerDbID, payeeDbID int
	var err error
	payerDbID, err = getOrCreateDBUser(payerDiscordID)
	if err != nil {
		return 0, fmt.Errorf("payer %s not found in DB for transaction matching: %w", payerDiscordID, err)
	}
	payeeDbID, err = getOrCreateDBUser(payeeDiscordID)
	if err != nil {
		return 0, fmt.Errorf("payee %s not found in DB for transaction matching: %w", payeeDiscordID, err)
	}

	var txID int
	query := `
SELECT id FROM transactions
WHERE payer_id = $1 AND payee_id = $2
AND ABS(amount - $3::numeric) < 0.01
AND already_paid = false
ORDER BY created_at DESC LIMIT 1;`
	err = dbPool.QueryRow(context.Background(), query, payerDbID, payeeDbID, amount).Scan(&txID)
	if err != nil {
		return 0, fmt.Errorf("no matching unpaid transaction")
	}
	log.Printf("Found matching transaction ID %d for Payer %s, Payee %s, Amount %.2f", txID, payerDiscordID, payeeDiscordID, amount)
	return txID, nil
}

func markTransactionPaidAndUpdateDebt(txID int) error {
	var payerDbID, payeeDbID int
	var amount float64

	tx, err := dbPool.Begin(context.Background())
	if err != nil {
		return fmt.Errorf("failed to begin database transaction: %w", err)
	}
	defer tx.Rollback(context.Background())

	err = tx.QueryRow(context.Background(),
		`SELECT payer_id, payee_id, amount FROM transactions WHERE id = $1 AND already_paid = false FOR UPDATE`, txID,
	).Scan(&payerDbID, &payeeDbID, &amount)
	if err != nil {
		return fmt.Errorf("failed to retrieve transaction %d or it's already paid: %w", txID, err)
	}

	_, err = tx.Exec(context.Background(), `UPDATE transactions SET already_paid = TRUE WHERE id = $1`, txID)
	if err != nil {
		return fmt.Errorf("failed to mark transaction %d as paid: %w", txID, err)
	}

	_, err = tx.Exec(context.Background(),
		`UPDATE user_debts SET amount = amount - $1, updated_at = CURRENT_TIMESTAMP
WHERE debtor_id = $2 AND creditor_id = $3`,
		amount, payerDbID, payeeDbID)
	if err != nil {
		log.Printf("Warning/Error updating user_debts for txID %d (debtor %d, creditor %d, amount %.2f): %v. This might be okay if debt was already < 0.", txID, payerDbID, payeeDbID, amount, err)
	}

	if err = tx.Commit(context.Background()); err != nil {
		return fmt.Errorf("failed to commit database transaction for txID %d: %w", txID, err)
	}
	log.Printf("Transaction ID %d marked as paid and debts updated.", txID)
	return nil
}

func updatePaidStatus(s *discordgo.Session, m *discordgo.MessageCreate) {
	parts := strings.Fields(m.Content)
	if len(parts) < 2 {
		sendErrorMessage(s, m.ChannelID, "‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡πÇ‡∏õ‡∏£‡∏î‡πÉ‡∏ä‡πâ `!paid <TxID1>[,<TxID2>,...]`")
		return
	}
	txIDStrings := strings.Split(parts[1], ",")
	var successMessages, errorMessages []string

	authorDbID, err := getOrCreateDBUser(m.Author.ID)
	if err != nil {
		sendErrorMessage(s, m.ChannelID, "‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏µ‡πâ")
		return
	}

	for _, txIDStr := range txIDStrings {
		trimmedTxIDStr := strings.TrimSpace(txIDStr)
		txID, err := strconv.Atoi(trimmedTxIDStr)
		if err != nil {
			errorMessages = append(errorMessages, fmt.Sprintf("‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö TxID '%s' ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á", trimmedTxIDStr))
			continue
		}

		var payeeDbID int
		var alreadyPaid bool
		err = dbPool.QueryRow(context.Background(),
			`SELECT t.payee_id, t.already_paid FROM transactions t WHERE t.id = $1`, txID).Scan(&payeeDbID, &alreadyPaid)
		if err != nil {
			errorMessages = append(errorMessages, fmt.Sprintf("‡πÑ‡∏°‡πà‡∏û‡∏ö TxID %d", txID))
			continue
		}

		if payeeDbID != authorDbID {
			errorMessages = append(errorMessages, fmt.Sprintf("‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÑ‡∏ß‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö TxID %d", txID))
			continue
		}

		if alreadyPaid {
			successMessages = append(successMessages, fmt.Sprintf("TxID %d ‡∏ñ‡∏π‡∏Å‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏ä‡∏≥‡∏£‡∏∞‡πÅ‡∏•‡πâ‡∏ß", txID))
			continue
		}

		err = markTransactionPaidAndUpdateDebt(txID)
		if err != nil {
			errorMessages = append(errorMessages, fmt.Sprintf("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï TxID %d: %v", txID, err))
		} else {
			successMessages = append(successMessages, fmt.Sprintf("TxID %d ‡∏ñ‡∏π‡∏Å‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏ä‡∏≥‡∏£‡∏∞‡πÅ‡∏•‡πâ‡∏ß", txID))
		}
	}

	var response strings.Builder
	if len(successMessages) > 0 {
		response.WriteString("‚úÖ **‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå:**\n")
		for _, msg := range successMessages {
			response.WriteString(fmt.Sprintf("- %s\n", msg))
		}
	}
	if len(errorMessages) > 0 {
		response.WriteString("‚ö†Ô∏è **‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î:**\n")
		for _, msg := range errorMessages {
			response.WriteString(fmt.Sprintf("- %s\n", msg))
		}
	}
	if response.Len() == 0 {
		response.WriteString("‡πÑ‡∏°‡πà‡∏°‡∏µ TxID ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•")
	}
	s.ChannelMessageSend(m.ChannelID, response.String())
}
